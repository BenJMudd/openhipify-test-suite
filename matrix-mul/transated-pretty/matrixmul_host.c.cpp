///////////////// Generated by Openhipify /////////////////
#include "hip/hip_runtime.h"

#include "matrixmul_kernel.cl.hpp"
///////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

#include <fcntl.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
////////////////////////////////////////////////////////////////////////////////
#define HB WA
#define WC WB
#define HC HA
////////////////////////////////////////////////////////////////////////////////

double CurTime() {
  struct timespec now;
  timespec_get(&now, TIME_UTC);
  return (double)now.tv_sec + (double)now.tv_nsec * 1e-9;
}

// Allocates a matrix with random float entries.
void randomMemInit(float *data, int size) {
  int i;

  for (i = 0; i < size; ++i)
    data[i] = rand() / (float)RAND_MAX;
}

void printResults(size_t size_C, float *h_C, int arrSize) {

  printf("\n\nMatrix C (Results)\n");
  int i;
  for (i = 0; i < size_C; i++) {
    printf("%f ", h_C[i]);
    if (((i + 1) % arrSize) == 0)
      printf("\n");
  }
  printf("\n");
}

int RunKernels(int arrSize, double *setTimeTotal, double *kernelTimeTotal) {

  double start, setupEnd, kernelEnd;

  start = CurTime();
  hipError_t err = hipSuccess; // error code returned from api calls

  // OpenCL device memory for matrices
  void *d_A;
  void *d_B;
  void *d_C;

  // set seed for rand()
  srand(2014);

  // Allocate host memory for matrices A and B
  unsigned int size_A = arrSize * arrSize;
  unsigned int mem_size_A = sizeof(float) * size_A;
  float *h_A = (float *)malloc(mem_size_A);

  unsigned int size_B = arrSize * arrSize;
  unsigned int mem_size_B = sizeof(float) * size_B;
  float *h_B = (float *)malloc(mem_size_B);

  // Initialize host memory
  randomMemInit(h_A, size_A);
  randomMemInit(h_B, size_B);

  // Allocate host memory for the result C
  unsigned int size_C = arrSize * arrSize;
  unsigned int mem_size_C = sizeof(float) * size_C;
  float *h_C = (float *)malloc(mem_size_C);

  // Create the input and output arrays in device memory for our calculation
  err = hipMalloc((void **)&d_C, mem_size_A);
  err = hipMalloc((void **)&d_A, mem_size_A);
  hipMemcpy(d_A, h_A, mem_size_A, hipMemcpyHostToDevice);
  err = hipMalloc((void **)&d_B, mem_size_B);
  hipMemcpy(d_B, h_B, mem_size_B, hipMemcpyHostToDevice);

  if (!d_A || !d_B || !d_C) {
    printf("Error: Failed to allocate device memory!\n");
    exit(1);
  }

  size_t blockSize[2] = {16, 16};
  size_t workSize[2] = {arrSize, arrSize};
  setupEnd = CurTime();
  hipLaunchKernelGGL(matrixMul,
                     dim3(arrSize / blockSize[0], arrSize / blockSize[0]),
                     dim3(blockSize[0], blockSize[0]), 0, 0, (float *)d_C,
                     (float *)d_A, (float *)d_B, arrSize, arrSize);

  // Retrieve result from device
  err = hipMemcpy(h_C, d_C, mem_size_C, hipMemcpyDeviceToHost);

  if (err != hipSuccess) {
    printf("Error: Failed to read output array! %d\n", err);
    exit(1);
  }

  kernelEnd = CurTime();
  // print out the results
  *setTimeTotal += setupEnd - start;
  *kernelTimeTotal += kernelEnd - setupEnd;
  // printResults(size_C, h_C, arrSize);
  // Shutdown and cleanup
  free(h_A);
  free(h_B);
  free(h_C);

  hipFree(d_A);
  hipFree(d_C);
  hipFree(d_B);
}

int main(int argc, char **argv) {
  int arrSize = atoi(argv[1]);
  int iters = atoi(argv[2]);
  double setupTime = 0;
  double kernelTime = 0;
  for (int i = 0; i < iters; ++i) {
    RunKernels(arrSize, &setupTime, &kernelTime);
  }
  printf("setup time: %f\n", setupTime);
  printf("kernel time: %f\n", kernelTime);
  return 0;
}
