///////////////// Generated by Openhipify /////////////////
#include "hip/hip_runtime.h"

#include "qr.cl.hpp"
///////////////////////////////////////////////////////////

__global__ void qr(float *u_vec, float *a_mat, float *q_mat, float *p_mat,
                   float *prod_mat) {

  __local__ float u_length_squared, dot;
  float prod, vec_length = 0.0f;

  int id = hipThreadIdx_x;
  int num_cols = hipBlockDim_x;

  /* Load first column into local memory as u vector */
  u_vec[id] = a_mat[id * num_cols];
  __threadfence_block();

  /* Find length of first A column and u vector */
  if (id == 0) {
    for (int i = 1; i < num_cols; i++) {
      vec_length += u_vec[i] * u_vec[i];
    }
    u_length_squared = vec_length;
    vec_length = sqrt(vec_length + u_vec[0] * u_vec[0]);
    a_mat[0] = vec_length;
    u_vec[0] -= vec_length;
    u_length_squared += u_vec[0] * u_vec[0];
  } else {
    a_mat[id * num_cols] = 0.0f;
  }
  __threadfence();

  /* Transform further columns of A */
  for (int i = 1; i < num_cols; i++) {
    dot = 0.0f;
    if (id == 0) {
      for (int j = 0; j < num_cols; j++) {
        dot += a_mat[j * num_cols + i] * u_vec[j];
      }
    }
    __threadfence_block();
    a_mat[id * num_cols + i] -= 2 * u_vec[id] * dot / u_length_squared;
  }

  /* Update Q matrix */
  for (int i = 0; i < num_cols; i++) {
    q_mat[id * num_cols + i] = -2 * u_vec[i] * u_vec[id] / u_length_squared;
  }
  q_mat[id * num_cols + id] += 1;
  __threadfence();

  /* Loop through other columns */
  for (int col = 1; col < num_cols - 1; col++) {

    /* Load new column into memory */
    u_vec[id] = a_mat[id * num_cols + col];
    __threadfence_block();

    /* Find length of A column and u vector */
    if (id == col) {
      vec_length = 0.0f;
      for (int i = col + 1; i < num_cols; i++) {
        vec_length += u_vec[i] * u_vec[i];
      }
      u_length_squared = vec_length;
      vec_length = sqrt(vec_length + u_vec[col] * u_vec[col]);
      u_vec[col] -= vec_length;
      u_length_squared += u_vec[col] * u_vec[col];
      a_mat[col * num_cols + col] = vec_length;
    } else if (id > col) {
      a_mat[id * num_cols + col] = 0.0f;
    }
    __threadfence();

    /* Transform further columns of A */
    for (int i = col + 1; i < num_cols; i++) {
      if (id == 0) {
        dot = 0.0f;
        for (int j = col; j < num_cols; j++) {
          dot += a_mat[j * num_cols + i] * u_vec[j];
        }
      }
      __threadfence_block();

      if (id >= col)
        a_mat[id * num_cols + i] -= 2 * u_vec[id] * dot / u_length_squared;
      __threadfence();
    }

    /* Update P matrix */
    if (id >= col) {
      for (int i = col; i < num_cols; i++) {
        p_mat[id * num_cols + i] = -2 * u_vec[i] * u_vec[id] / u_length_squared;
      }
      p_mat[id * num_cols + id] += 1;
    }
    __threadfence();

    /* Multiply q_mat * p_mat = prod_mat */
    for (int i = col; i < num_cols; i++) {
      prod = 0.0f;
      for (int j = col; j < num_cols; j++) {
        prod += q_mat[id * num_cols + j] * p_mat[j * num_cols + i];
      }
      prod_mat[id * num_cols + i] = prod;
    }
    __threadfence();

    /* Place the content of prod_mat in q_mat */
    for (int i = col; i < num_cols; i++) {
      q_mat[id * num_cols + i] = prod_mat[id * num_cols + i];
    }
    __threadfence();
  }
}
