///////////////// Generated by Openhipify /////////////////
#include "hip/hip_runtime.h"

#include "vec-add-standard.cl.hpp"
///////////////////////////////////////////////////////////

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include <sys/time.h>
#include <time.h>

#define MEM_SIZE (128)
#define MAX_SOURCE_SIZE (0x100000)
#define PRINT_LINE(title) printf("\n========== %s ==========\n", title);

void init_vec(int *vec, int len, int set_one_flag) {
  for (int i = 0; i < len; i++) {
    if (set_one_flag)
      vec[i] = 1;
    else
      vec[i] = 0;
  }
}

void rand_vec(int *vec, int len) {
  srand((unsigned)time(0));
  for (int i = 0; i < len; i++) {
    vec[i] = rand() % 2;
  }
}

void add_vec_cpu(const int *a, const int *b, int *res, const int len) {
  for (int i = 0; i < len; i++) {
    res[i] = a[i] + b[i];
  }
}

void print_vec(int *vec, int len) {
  for (int i = 0; i < len; i++) {
    printf("%d ", vec[i]);
  }
  printf("\n");
}

void check_result(int *v1, int *v2, int len) {
  int correct_num = 0;
  for (int i = 0; i < len; i++) {
    if (v1[i] == v2[i]) {
      correct_num += 1;
    }
  }
  printf("correct rate: %d / %d , %1.2f\n", correct_num, len,
         (float)correct_num / len);
}

int main(void) {
  struct timeval start, finish;
  double duration;
  srand((unsigned)time(NULL));

  /* generate vector a and b */
  int len = 64;
  int *a, *b, *c, *c_d;
  a = (int *)malloc(len * sizeof(int));
  b = (int *)malloc(len * sizeof(int));
  c = (int *)malloc(len * sizeof(int));
  c_d = (int *)malloc(len * sizeof(int));
  size_t data_size = len * sizeof(int);

  PRINT_LINE("INIT VALUE");
  /* vector addition, cpu version */
  printf("a: ");
  init_vec(a, len, 1);
  print_vec(a, len);

  printf("b: ");
  rand_vec(b, len);
  print_vec(b, len);

  printf("c: ");
  init_vec(c, len, 0);
  add_vec_cpu(a, b, c, len);
  print_vec(c, len);

  /* vector addition, gpu version  */
  void *a_buff, *b_buff, *c_buff;
  a_buff = b_buff = c_buff = NULL;

  hipError_t ret = hipSuccess;

  // Platform

  if (ret != hipSuccess) {
    printf("Failed to get platform ID.\n");
    goto error;
  }
  // Device

  if (ret != hipSuccess) {
    printf("Failed to get device ID.\n");
    goto error;
  }
  // Context
  //&ret);
  if (ret != hipSuccess) {
    printf("Failed to create OpenCL context.\n");
    goto error;
  }

  if (ret != hipSuccess) {
    printf("Failed to create command queue %d\n", (int)ret);
    goto error;
  }
  // Memory Buffer
  ret = hipMalloc((void **)&a_buff, data_size);
  ret = hipMalloc((void **)&b_buff, data_size);
  ret = hipMalloc((void **)&c_buff, data_size);

  ret = hipMemcpy(a_buff, (void *)a, data_size, hipMemcpyHostToDevice);
  ret = hipMemcpy(b_buff, (void *)b, data_size, hipMemcpyHostToDevice);
  if (ret != hipSuccess) {
    printf("Failed to copy date from host to device: %d\n", (int)ret);
    goto error;
  }
  // Create Kernel Program from source

  // Create OpenCL Kernel

  if (ret != hipSuccess) {
    printf("Failed to create kernel %d\n", (int)ret);
    goto error;
  }

  if (ret != hipSuccess) {
    printf("Failed to set kernel arguments %d\n", (int)ret);
    goto error;
  }

  /* Execute OpenCL Kernel */
  // executed using a single work-item
  // ret = clEnqueueTask(command_queue, kernel, 0, NULL, NULL);

  size_t global_work_size, local_work_size;
  // Number of work items in each local work group
  local_work_size = len;
  // Number of total work items - localSize must be devisor
  global_work_size =
      (size_t)ceil(len / (float)local_work_size) * local_work_size;

  // size_t local_work_size[2] = { 8, 8 };
  // size_t global_work_size[2] = { 1, len };
  hipLaunchKernelGGL(add_vec_gpu, dim3(global_work_size), dim3(local_work_size),
                     0, 0, (const int *)a_buff, (const int *)b_buff,
                     (int *)c_buff, len);
  if (ret != hipSuccess) {
    printf("Failed to execute kernel for execution %d\n", (int)ret);
    goto error;
  }

  init_vec(c_d, len, 0);
  /* Copy results from the memory buffer */
  ret = hipMemcpy((void *)c_d, c_buff, data_size, hipMemcpyDeviceToHost);
  if (ret != hipSuccess) {
    printf("Failed to copy data from device to host %d\n", (int)ret);
    goto error;
  }

  /* Display Result */
  PRINT_LINE("CHECK RESULT cpu-verison && gpu-version");
  printf("c_d: ");
  print_vec(c_d, len);
  check_result(c, c_d, len);
  printf("len-1=%d, c_d[%d]==c[%d]: %d, c_d[%d]=%d, c[%d]=%d \n", len - 1,
         len - 1, len - 1, c_d[len - 1] == c[len - 1], len - 1, c_d[len - 1],
         len - 1, c[len - 1]);

  PRINT_LINE("CHECK RESULT ELEMENT BY ELEMENT");
  printf("idx  c  c_d\n");
  for (int i = 0; i < len; i++) {
    printf("%2d %2d %2d \n", i, c[i], c_d[i]);
  }

  /* Finalization */
error:

  /* free device resources */

  hipFree(a_buff);
  hipFree(b_buff);
  hipFree(c_buff);

  /* free host resources */
  free(a);
  free(b);
  free(c);

  return 0;
}
